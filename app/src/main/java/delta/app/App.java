/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package delta.app;

import io.javalin.Javalin;
import io.javalin.http.sse.SseClient;
import io.javalin.plugin.bundled.CorsPluginConfig;
import io.javalin.websocket.WsContext;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Queue;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.Stream;

public class App {

    public static void main(String[] args) {
        new App().start();
    }

    private final String CSV_FILE_NAME = "LogReply.csv";

    private final Javalin app;

    private int noOfMessages = 0;

    private final Queue<SseClient> sseClients = new ConcurrentLinkedQueue<>();
    private final Queue<WsContext> wsClients = new ConcurrentLinkedQueue<>();
    private final Queue<CompletableFuture<Long>> lpClients = new ConcurrentLinkedQueue<>();

    private final Queue<ReturnRecord> logReply = new ConcurrentLinkedQueue<>();


    public App() {
        app = Javalin.create(config -> config.plugins.enableCors(cors -> cors.add(CorsPluginConfig::anyHost)));

        configureReturn();
        configureServerSentEvents();
        configureWebsocket();
        configureLongPolling();
    }

    public void start() {
        app.start(7070);

        Executors.newScheduledThreadPool(1).scheduleAtFixedRate(this::sendMessage, 0L, 1L, TimeUnit.SECONDS);
    }

    private void configureReturn() {
        app.post("/return", ctx -> {
            var currentTime = System.nanoTime();
            var record = ctx.bodyAsClass(ReturnRecord.class);
            var deltaTime = currentTime - record.nanoTime();

            logReply.add(new ReturnRecord(record.protocol(),deltaTime  ));

            System.out.println(record.protocol() + ";" + (currentTime - record.nanoTime()) + "no of replies: " + logReply.size());
        });
    }

    private void configureServerSentEvents() {
        app.sse("/sse", sseClient -> {
            sseClient.keepAlive();
            sseClient.onClose(() -> sseClients.remove(sseClient));
            sseClients.add(sseClient);
        });
    }

    private void configureWebsocket() {
        app.ws("/ws", ws -> {
            ws.onConnect(wsClients::add);
            ws.onClose(wsClients::remove);
        });
    }

    private void configureLongPolling() {
        app.get("/lp", ctx -> {
            CompletableFuture<Long> lpFuture = new CompletableFuture<>();
            lpClients.add(lpFuture);
            ctx.future(() -> lpFuture.thenAccept(response -> ctx.result(String.valueOf(response))));
        });
    }


    private void sendMessage() {
        //test
        if(  20 < noOfMessages++  )
            return;

        if( noOfMessages == 20 )
            writeLogReplyToCSV();

        sseClients.forEach(sseClient -> sseClient.sendEvent(System.nanoTime()));

        wsClients.forEach(wsClient -> wsClient.send(System.nanoTime()));

        CompletableFuture<Long> lpFuture;
        while ((lpFuture = lpClients.poll()) != null) {
            lpFuture.complete(System.nanoTime());
        }
    }


    private void writeLogReplyToCSV()  {
        File csvOutputFile = new File(CSV_FILE_NAME);
        try (PrintWriter pw = new PrintWriter(csvOutputFile)) {
            logReply.stream()
                    .map(this::convertRecToLine)
                    .forEach(pw::println);
        } catch (FileNotFoundException e) {
            System.out.println("File no found: " + e.getMessage());
            throw new RuntimeException(e);
        }
    }

    private String convertRecToLine(ReturnRecord qData) {
        return qData.protocol() + ";" + qData.nanoTime();


    }

}
